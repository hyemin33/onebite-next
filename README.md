# 프로젝트명

한 입 크기로 잘라먹는 Next.js 인강 정리

## section02 Page Router

Page Router에 대한 내용을 실습합니다.

1. 경로

- []와 useRouter를 사용하여 쿼리 값을 가져온다.
- [...id] : .../id/id2/id3 .. 뒤에 여러개의 id를 가져올 수 있다. (=Catch All Segment)
- [[...id]] : .../ index 파일까지 범용적으로 쓰고 싶다면 대괄호를 한번 더 감싼다. ( =Optional Catch All Segment)

---

2. 네비게이팅

- a태그는 CSR방식으로 이동시키기 때문에 (매번 서버에 새로운 페이지를 요청함) next 내장객체인 Link 태그를 사용한다.
- 프로그래매틱한 페이지 이동(Programmatic Navigation) : 사용자가 링크를 직접 클릭했을때 이동하는 것이 아니라 특정 버튼이 클릭되었거나, 특정 조건이 만족했을때 함수 내에서 이동시키는 방법
  ex) 함수 내부에서 조건 만족시 페이지 이동

---

3. 프리페칭

- 현재 사용자가 보고 있는 페이지 내에서 이동할 가능성이 있는 모든 페이지의 js bundel을 미리 불러오는 것 => 빠른 페이지 이동을 제공함.
- Link 태그로 연결된 페이지만 프리페칭이 이루어지지만, 프로그래매틱한 페이지도 쓰고 싶다면 `router.prefetch`를 사용한다.
- Link 태그 중 프리패치를 원하지 않는 페이지가 있다면 `prefetch={false}`를 추가하면 된다.
  ```
  // 마운트될때 프리패칭을 해주고 싶다면 router.prefetch를 사용한다.
  useEffect(() => {
    router.prefetch("/book");
  }, []);
  ```

---

4. 스타일

- .css파일은 App 파일이 아닌 곳에서 불러올 수 없다.(css의 클래스명이 겹치는 것을 원천 차단 시키기 위해) 그렇기에 Next에서는 CSS Module을 사용한다.
- CSS Module은 유니크한 클래스명으로 자동 변환된다.

---

5. 글로벌 레이아웃

- \_app.tsx에서 글로벌 레이아웃, 스타일링을 해준다.

---

6. 페이지별 레이아웃

- Page.getLayout과 같이 필요한 페이지에 메서드를 정의하고 app 컴포넌트에서 불러와서 적용시킨다. getLayout이 없는 페이지가 있을 수 있으므로 `??`연산자를 사용하여 예외처리를 한다.

---

7. 사전 렌더링과 데이터 페칭

- 리액트는 컴포넌트 마운트 이후에 데이터 페칭이 이루어진다. 그렇기 때문에 데이터 요청 시점이 느려지게 되는 단점이 발생한다.
- Next는 사전 렌더링 중에 데이터 페칭까지 진행하기 때문에 리액트보다 데이터 요청 시간이 앞당겨지게 된다. 그로인해 사용자는 추가 데이터 로딩 없이 데이터 페칭이 완료된 페이지를 바로 볼 수 있다.
- 만약 사전 렌더링 과정 중 데이터 페칭의 용량이 크거나 느려질 경우, 빌드타임에 렌더링을 맞춰두는 설정을 할 수 있다. = SSG
- Next에는 SSR, SSG, ISR이 존재한다.

---

8. SSR

- 가장 기본적인 사전 렌더링 방식으로 요청이 들어올 때 마다 사전 렌더링을 진행한다.
- `getServerSideProps` 함수를 사용하면 SSR로 내보낼 수 있다. 컴포넌트보다 먼저 실행되어서 컴포넌트에 필요한 데이터를 불러오는 함수이다.
  type은 `InferGetServerSidePropsType`로 사용한다.

  ```
  export const getServerSideProps = () => {
  const data = "hello";

    return {
      props: {
        data,
      },
    };
  };
  ```

- getServerSideProps는 서버쪽에서 실행하기 때문에 브라우저 객체는 사용하지 못한다.
- getServerSideProps에는 context라는 매개변수를 사용하여 다양한 정보를 가져올 수 있다. (쿼리 값 등등)

---

9. SSG

- SSR의 단점을(사전 렌더링에 많은 시간이 소요될 경우) 해결하는 사전 렌더링 방식으로 빌드타임에 사전 렌더링을 한다.
- 빌드타임 이후에는 사전 렌더링을 하지 않기 때문에 항상 같은 데이터를 보여준다. 최신 데이터를 반영하기는 어렵다. = 정적인 페이지에서 써야한다.
- 사용 방법은 getServerSideProps와 같은데 getStaticProps로 바꿔서 사용하면 된다.
- context의 쿼리를 쓰려면 CSR처럼 만드는 방법뿐이다.
- 동적페이지에서는 동적 경로를 미리 설정해두어야 사전 렌더링이 가능하다. (= getStaticPaths)
  ```
    export const getStaticPaths = () => {
      return {
        paths: [
          { params: {id: "1"}},
          { params: {id: "2"}},
          { params: {id: "3"}},
        ],
        fallback: false
      }
    }
  ```
- fallback option(경로 없을 시)
  -- false: 404 Not Found 반환
  -- blocking: 즉시 생성(SSR) 이후 생성된 페이지는 SSG가 됨
  -- true: 즉시 생성 + 페이지만 미리 반환해서 전송 후 나중에 데이터를 계산해서 보냄

---

10. ISR (추천!!)

- SSG방식으로 생성된 정적 페이지를 일정 시간을 주기로 다시 생성하는 기술
- getStaticProps 함수 안에 revalidate를 추가한다.
- ISR을 쓰기 어려운 페이지 : 시간과 관계없이 사용자의 행동에 따라 데이터가 업데이트 되는 페이지 (게시물 수정, 삭제 등)

---

11. On-Demand ISR

- 요청을 받을 때 마다 ISR 페이지를 다시 생성한다. (게시글 수정,삭제 시 동작함)

---

12. SEO 설정

- meta tag를 각 페이지별로 설정이 가능하다.
- SSG fallback 상태일때도 작동하도록 기본 meta tag를 추가해준다.

---

<br/><br/>

## section03 App Router

1. 경로

- page.tsx 만 경로로 인정된다.
- 쿼리스트링, 파라미터 등은 Page 컴포넌트의 props에 자동으로 전달된다. SSR이라 비동기이기 때문에 Promise 를 사용해서 꺼내와야 한다.
  ```
  export default async function Page({
    params,
  }: {
    params: Promise<{ id: string }>;
  }) { ... }
  ```
- 동적 경로를 동적으로 쓰고 싶다면 Catch All Segment로 설정한다. (= [...id])

---

2. 레이아웃

- layout 파일을 만들면 해당 경로의 page를 감싸는 형태가 된다.
- 특정 경로에만 보이게 하는 layout을 설정하고 싶다면 라우트 그룹을 사용한다. () 괄호를 사용하여 폴더를 만든다. 이때 ()는 경로에 영향을 주지 않는다.

---

3. 리액트 서버 컴포넌트

- 페이지 라우트의 경우 상호작용이 필요하지 않는 컴포넌트까지 번들링이 되기 때문에 자바스크립트 번들의 용량이 불필요하게 커지는 단점이 있었다. 이로인해 번들을 불러오는 속도가 늘어나게 되고, 하이드레이션 시간까지 늘어나게 되어 TTI도 늦어지게 된다.
  이러한 문제를 해결하기 위해서는 상호작용이 없는 컴포넌트를 클라이언트에 전달되지 않도록 다른 유형으로 분리하는 것이 필요했고, 리액트 서버 컴포넌트가 생기게 된다.
- 서버측에서 사전 렌더링을 진행할 때 딱 한번만 실행 되므로 브라우저에서 실행되지 않는다. (기본적으로 모든 컴포넌트가 서버 컴포넌트라 따로 설정할 것이 없다.)
- 서버측 컴포넌트이므로 리액트 hook을 사용할 수 없다.
- 클라이언트 컴포넌트 : 사전 렌더링 진행할 때 한번, 하이드레이션 진행할 때 한번, 총 2번 실행한다. (use client 를 사용하면 된다.)
  ==> 페이지의 대부분을 서버 컴포넌트로 구성할 것을 권장하며, 클라이언트 컴포넌트는 꼭 필요한 경우에만 사용할 것

---

4. 어떠한 경우 클라이언트 컴포넌트를 사용해야 하는가?

- 상호작용이 있는 경우 클라이언트 컴포넌트로 만들고, 그게 아닌 경우 모두 서버 컴포넌트로 만든다.
- 상호 작용 있음 = 서치바
- 상호 작용 없음 = BookItem, BookList ...

---

5. 리액트 서버 컴포넌트 주의사항

- 서버 컴포넌트에는 브라우저에서 실행될 코드가 포함되면 안된다.
- 클라이언트 컴포넌트는 클라이언트에서만 실행되지 않는다.
- 클라이언트 컴포넌트에서 서버 컴포넌트를 import 할 수 없다. import를 해올 경우 강제로 클라이언트 컴포넌트로 변환된다. 만약 클라이언트 컴포넌트 안에 서버 컴포넌트를 꼭 써야 하는 경우라면 children을 사용해서 서버 컴포넌트를 가져오면 서버 컴포넌트 그대로 사용할 수 있다.
- 서버 컴포넌트에서 클라이언트 컴포넌트에게 직렬화 되지 않는 props는 전달 불가하다. (함수 등..)

---

6. 네비게이팅

- 페이지 이동 시 자바스크립트 번들과 RSC Payload(서버 컴포넌트 정보)가 함께 전달된 후 페이지가 교체된다.
- 프로매틱한 페이지 이동은 next/navigation의 useRouter를 사용한다.
- 동적인 페이지는 SSR 방식이기 때문에 자바스크립트 번들 없이 RSC만 프리패칭 된다.

---

7. 프리패칭 간략 설명

- App Router에서는 Static 또는 Dynamic 2가지 뿐이다. Static은 RSC와 JS번들 2가지를 모두 받아오고(프리패치), Dynamic은 RSC만 받아오고 향후에 페이지를 이동했을때 JS번들을 받는다.
